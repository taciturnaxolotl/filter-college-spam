// filename: Code.gs
// Strict triage using ai.hackclub.com with fail-safe to inbox.
// Handles Gmail API quotas, AI rate limits, and Apps Script execution limits.

const AUTO_LABEL_NAME = "College/Auto";
const FILTERED_LABEL_NAME = "College/Filtered";
const DRY_RUN = false;

const AI_BASE_URL = "https://ai.hackclub.com/proxy/v1/chat/completions";
const AI_MODEL = "deepseek/deepseek-r1-distill-qwen-32b";
const AI_API_KEY = PropertiesService.getScriptProperties().getProperty("AI_API_KEY");

// Rate limit configuration
const MAX_AI_RETRIES = 3;
const AI_TIMEOUT_MS = 15000; // 15 second timeout
const MAX_THREADS_PER_RUN = 50; // Process max 50 threads per execution
const MAX_EXECUTION_TIME_MS = 4.5 * 60 * 1000; // 4.5 minutes (Apps Script has 6min limit)
const AI_RATE_LIMIT_DELAY_MS = 1000; // 1 second between AI calls to avoid rate limits
const GMAIL_BATCH_SIZE = 10; // Process Gmail operations in batches

// Rate limit tracking
const RATE_LIMIT_PROPERTY = "AI_RATE_LIMIT_RESET";
const RATE_LIMIT_COUNT_PROPERTY = "AI_RATE_LIMIT_COUNT";
const MAX_AI_CALLS_PER_HOUR = 100; // Adjust based on your AI provider's limits

function ensureLabels() {
  getOrCreateLabel_(AUTO_LABEL_NAME);
  getOrCreateLabel_(FILTERED_LABEL_NAME);
  Logger.log(`Labels ensured: ${AUTO_LABEL_NAME}, ${FILTERED_LABEL_NAME}`);
}

function runTriage() {
  const startTime = Date.now();
  
  if (!AI_API_KEY) {
    Logger.log("ERROR: AI_API_KEY not set in Script properties. Cannot proceed.");
    throw new Error("Set AI_API_KEY in Script properties.");
  }

  // Check if we're rate limited
  if (isRateLimited_()) {
    const resetTime = new Date(parseInt(PropertiesService.getScriptProperties().getProperty(RATE_LIMIT_PROPERTY)));
    Logger.log(`Rate limited. Will reset at ${resetTime.toISOString()}`);
    return;
  }

  const autoLabel = getOrCreateLabel_(AUTO_LABEL_NAME);
  const filteredLabel = getOrCreateLabel_(FILTERED_LABEL_NAME);

  let threads = autoLabel.getThreads(0, MAX_THREADS_PER_RUN);
  if (!threads.length) {
    Logger.log("No threads under College/Auto.");
    return;
  }

  Logger.log(`Processing up to ${threads.length} threads (max ${MAX_THREADS_PER_RUN} per run)`);

  let stats = {
    wouldInbox: 0,
    wouldFiltered: 0,
    didInbox: 0,
    didFiltered: 0,
    errors: 0,
    skipped: 0,
    rateLimited: 0
  };

  let aiCallCount = 0;
  const maxAICalls = MAX_AI_CALLS_PER_HOUR - getCurrentRateLimitCount_();
  
  for (let i = 0; i < threads.length; i++) {
    // Check execution time limit
    const elapsed = Date.now() - startTime;
    if (elapsed > MAX_EXECUTION_TIME_MS) {
      Logger.log(`Execution time limit approaching (${elapsed}ms). Stopping. Processed ${i}/${threads.length} threads.`);
      stats.skipped = threads.length - i;
      break;
    }

    // Check AI rate limit
    if (aiCallCount >= maxAICalls) {
      Logger.log(`AI rate limit reached (${aiCallCount} calls). Stopping. Processed ${i}/${threads.length} threads.`);
      stats.skipped = threads.length - i;
      stats.rateLimited = threads.length - i;
      break;
    }

    const thread = threads[i];
    
    try {
      const needsAI = processThread_(thread, autoLabel, filteredLabel, stats);
      
      if (needsAI) {
        aiCallCount++;
        incrementRateLimitCount_();
        
        // Add delay between AI calls to avoid rate limits
        if (i < threads.length - 1) {
          Utilities.sleep(AI_RATE_LIMIT_DELAY_MS);
        }
      }
    } catch (e) {
      Logger.log(`ERROR processing thread ${thread.getId()}: ${e}. FAIL-SAFE: Moving to inbox.`);
      stats.errors += 1;
      
      // FAIL-SAFE: On error, send to inbox
      if (!DRY_RUN) {
        try {
          thread.removeLabel(autoLabel);
          thread.removeLabel(filteredLabel);
          thread.moveToInbox();
          stats.didInbox += 1;
        } catch (moveError) {
          Logger.log(`CRITICAL: Could not move thread ${thread.getId()} to inbox: ${moveError}`);
        }
      } else {
        stats.wouldInbox += 1;
      }
    }

    // Periodic batch processing to avoid Gmail quota issues
    if ((i + 1) % GMAIL_BATCH_SIZE === 0) {
      Utilities.sleep(100); // Small delay between batches
    }
  }

  const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
  Logger.log(`Summary DRY_RUN=${DRY_RUN}: WouldInbox=${stats.wouldInbox}, WouldFiltered=${stats.wouldFiltered}, AppliedInbox=${stats.didInbox}, AppliedFiltered=${stats.didFiltered}, Errors=${stats.errors}, Skipped=${stats.skipped}, RateLimited=${stats.rateLimited}, Time=${totalTime}s, AICalls=${aiCallCount}`);
  
  if (stats.skipped > 0) {
    Logger.log(`WARNING: ${stats.skipped} threads not processed. Will be picked up in next run.`);
  }
}

// Returns true if AI was called, false if local rules were used
function processThread_(thread, autoLabel, filteredLabel, stats) {
  const msg = thread.getMessages().slice(-1)[0];
  if (!msg) {
    throw new Error("No messages in thread");
  }

  const meta = {
    subject: safeStr_(msg.getSubject()),
    body: safeStr_(msg.getPlainBody(), 10000),
    from: safeStr_(msg.getFrom()),
    to: safeStr_(msg.getTo()),
    cc: safeStr_(msg.getCc()),
    date: msg.getDate()
  };

  // Validate we have minimum required data
  if (!meta.subject && !meta.body) {
    Logger.log(`WARNING: Thread ${thread.getId()} has no subject or body. FAIL-SAFE: Moving to inbox.`);
    applyInboxAction_(thread, autoLabel, filteredLabel, stats, "no content (fail-safe)");
    return false; // No AI call
  }

  // Local strict rules first (most reliable)
  const local = localStrictDecision_(meta);
  let relevant, reason;

  if (local.decided) {
    relevant = local.pertains;
    reason = local.reason;
    Logger.log(`[Thread ${thread.getId()}] Local decision: Relevant=${relevant} Reason="${reason}" Subject="${meta.subject}" From="${meta.from}"`);
    
    // Apply decision
    if (relevant) {
      applyInboxAction_(thread, autoLabel, filteredLabel, stats, reason);
    } else {
      applyFilteredAction_(thread, autoLabel, filteredLabel, stats, reason);
    }
    
    return false; // No AI call needed
  }

  // Need AI classification
  const ai = classifyWithAIRetry_(meta);
  
  // FAIL-SAFE: If AI completely failed, send to inbox
  if (ai.error) {
    Logger.log(`[Thread ${thread.getId()}] AI failed after retries. FAIL-SAFE: Moving to inbox. Subject="${meta.subject}" From="${meta.from}"`);
    applyInboxAction_(thread, autoLabel, filteredLabel, stats, "AI failure (fail-safe)");
    return true; // AI was attempted
  }

  // Enforce strict rules on AI output
  const forced = enforceStrictRules_(meta, ai);
  relevant = forced.pertains;
  reason = forced.reason;
  
  Logger.log(`[Thread ${thread.getId()}] Model=${AI_MODEL} Relevant=${relevant} Reason="${reason}" Subject="${meta.subject}" From="${meta.from}"`);

  // Apply decision
  if (relevant) {
    applyInboxAction_(thread, autoLabel, filteredLabel, stats, reason);
  } else {
    applyFilteredAction_(thread, autoLabel, filteredLabel, stats, reason);
  }
  
  return true; // AI was called
}

function applyInboxAction_(thread, autoLabel, filteredLabel, stats, reason) {
  if (DRY_RUN) {
    stats.wouldInbox += 1;
    Logger.log(`  DRY_RUN: Would remove "${AUTO_LABEL_NAME}" and move to Inbox (${reason})`);
  } else {
    try {
      thread.removeLabel(autoLabel);
      thread.removeLabel(filteredLabel);
      thread.moveToInbox();
      stats.didInbox += 1;
      Logger.log(`  Applied: Removed "${AUTO_LABEL_NAME}" (+ "${FILTERED_LABEL_NAME}") and moved to Inbox (${reason})`);
    } catch (e) {
      Logger.log(`  ERROR applying inbox action: ${e}`);
      throw e;
    }
  }
}

function applyFilteredAction_(thread, autoLabel, filteredLabel, stats, reason) {
  if (DRY_RUN) {
    stats.wouldFiltered += 1;
    Logger.log(`  DRY_RUN: Would add "${FILTERED_LABEL_NAME}" and keep archived (${reason})`);
  } else {
    try {
      thread.removeLabel(autoLabel);
      thread.addLabel(filteredLabel);
      if (thread.isInInbox()) thread.moveToArchive();
      stats.didFiltered += 1;
      Logger.log(`  Applied: Added "${FILTERED_LABEL_NAME}" and archived if needed (${reason})`);
    } catch (e) {
      Logger.log(`  ERROR applying filtered action: ${e}`);
      throw e;
    }
  }
}

// ---------- Rate Limiting ----------
function isRateLimited_() {
  const props = PropertiesService.getScriptProperties();
  const resetTime = props.getProperty(RATE_LIMIT_PROPERTY);
  
  if (!resetTime) return false;
  
  const now = Date.now();
  const reset = parseInt(resetTime);
  
  if (now >= reset) {
    // Rate limit period expired, reset counter
    props.deleteProperty(RATE_LIMIT_PROPERTY);
    props.deleteProperty(RATE_LIMIT_COUNT_PROPERTY);
    return false;
  }
  
  const count = getCurrentRateLimitCount_();
  return count >= MAX_AI_CALLS_PER_HOUR;
}

function getCurrentRateLimitCount_() {
  const count = PropertiesService.getScriptProperties().getProperty(RATE_LIMIT_COUNT_PROPERTY);
  return count ? parseInt(count) : 0;
}

function incrementRateLimitCount_() {
  const props = PropertiesService.getScriptProperties();
  const count = getCurrentRateLimitCount_() + 1;
  props.setProperty(RATE_LIMIT_COUNT_PROPERTY, count.toString());
  
  // Set reset time if not set (1 hour from now)
  if (!props.getProperty(RATE_LIMIT_PROPERTY)) {
    const resetTime = Date.now() + (60 * 60 * 1000); // 1 hour
    props.setProperty(RATE_LIMIT_PROPERTY, resetTime.toString());
  }
  
  if (count >= MAX_AI_CALLS_PER_HOUR) {
    Logger.log(`Rate limit reached: ${count}/${MAX_AI_CALLS_PER_HOUR} calls`);
  }
}

function handleAIRateLimit_(response) {
  const status = response.getResponseCode();
  
  // Common rate limit status codes
  if (status === 429 || status === 503) {
    const props = PropertiesService.getScriptProperties();
    
    // Check for Retry-After header
    const retryAfter = response.getHeaders()['Retry-After'];
    let resetTime;
    
    if (retryAfter) {
      // Could be seconds or HTTP date
      const retrySeconds = parseInt(retryAfter);
      if (!isNaN(retrySeconds)) {
        resetTime = Date.now() + (retrySeconds * 1000);
      } else {
        // Try parsing as date
        try {
          resetTime = new Date(retryAfter).getTime();
        } catch (e) {
          // Default to 1 hour
          resetTime = Date.now() + (60 * 60 * 1000);
        }
      }
    } else {
      // Default to 1 hour
      resetTime = Date.now() + (60 * 60 * 1000);
    }
    
    props.setProperty(RATE_LIMIT_PROPERTY, resetTime.toString());
    props.setProperty(RATE_LIMIT_COUNT_PROPERTY, MAX_AI_CALLS_PER_HOUR.toString());
    
    Logger.log(`AI rate limit detected (HTTP ${status}). Reset at: ${new Date(resetTime).toISOString()}`);
    return true;
  }
  
  return false;
}

// ---------- Strict local rules (most reliable) ----------
function localStrictDecision_(meta) {
  const s = (meta.subject || "").toLowerCase();
  const b = (meta.body || "").toLowerCase();

  // 1. Security / password alerts (ALWAYS relevant)
  const security = [
    /\bpassword\s+(reset|change|update|expired)\b/,
    /\breset\s+your\s+password\b/,
    /\baccount\s+security\b/,
    /\bsecurity\s+alert\b/,
    /\bunusual\s+sign[- ]?in\b/,
    /\bverification\s+code\b/,
    /\b(2fa|mfa|two[- ]factor)\b/,
    /\bcompromised\s+account\b/,
    /\baccount\s+(locked|suspended)\b/,
    /\bsuspicious\s+activity\b/,
  ];
  for (const pat of security) {
    if (pat.test(s) || pat.test(b)) {
      return { decided: true, pertains: true, reason: "security/password alert (strict local rule)" };
    }
  }

  // 2. Scholarship explicitly awarded (NOT held/consideration)
  const awardPos = [
    /\bcongratulations\b.*\bscholarship\b/,
    /\byou\s+(have|received|are\s+awarded|won)\b.*\bscholarship\b/,
    /\bwe\s+(are\s+)?(pleased\s+to\s+)?award(ing)?\b.*\bscholarship\b/,
    /\bscholarship\s+(offer|award)\b/,
    /\breceived\s+a\s+scholarship\b/,
  ];
  const awardNeg = [
    /\bscholarship\b.*\b(held|reserved)\s+for\s+you\b/,
    /\bbeing\s+held\s+for\s+you\b/,
    /\bconsider(ed|ation)\b.*\bscholarship\b/,
    /\bscholarship\b.*\bconsider(ed|ation)\b/,
    /\bapply\b.*\bscholarship\b/,
    /\bscholarship\b.*\bapply\b/,
    /\b(guaranteed|automatic)\s+admission\b/,
    /\bpriority\s+consideration\b/,
    /\beligible\s+for\b.*\bscholarship\b/,
    /\bscholarship\b.*\beligible\b/,
    /\bmay\s+qualify\b.*\bscholarship\b/,
  ];
  
  for (const pat of awardPos) {
    if (pat.test(s) || pat.test(b)) {
      for (const neg of awardNeg) {
        if (neg.test(s) || neg.test(b)) {
          return { decided: true, pertains: false, reason: "scholarship NOT awarded (held/consideration/apply/eligible)" };
        }
      }
      return { decided: true, pertains: true, reason: "scholarship awarded (strict local rule)" };
    }
  }

  // 3. Financial aid offer ready/available to review (explicit offer)
  const aidPos = [
    /\bfinancial\s+aid\b.*\boffer\b.*\b(ready|available)\b/,
    /\b(ready|available)\b.*\bfinancial\s+aid\b.*\boffer\b/,
    /\baward\s+letter\b.*\b(ready|available|posted|view)\b/,
    /\b(view|review)\s+(your\s+)?award\s+letter\b/,
    /\bfinancial\s+aid\s+package\b.*\b(ready|available|posted)\b/,
    /\byour\s+aid\s+is\s+ready\b/,
  ];
  const aidNeg = [
    /\blearn\s+more\s+about\b.*\bfinancial\s+aid\b/,
    /\bapply\b.*\b(for\s+)?financial\s+aid\b/,
    /\bfinancial\s+aid\b.*\bapplication\b/,
    /\bcomplete\s+(your\s+)?fafsa\b/,
    /\bconsidered\s+for\b.*\baid\b/,
  ];
  
  for (const pat of aidPos) {
    if (pat.test(s) || pat.test(b)) {
      for (const neg of aidNeg) {
        if (neg.test(s) || neg.test(b)) {
          return { decided: true, pertains: false, reason: "financial aid marketing/application (not ready offer)" };
        }
      }
      return { decided: true, pertains: true, reason: "financial aid offer ready (strict local rule)" };
    }
  }

  // 4. Response to student action (application, enrollment)
  const actionResponse = [
    /\bapplication\s+(received|complete|submitted)\b/,
    /\breceived\s+your\s+application\b/,
    /\bthank\s+you\s+for\s+(applying|submitting)\b/,
    /\bdual\s+enrollment\b.*\b(confirmation|registered|approved)\b/,
    /\benrollment\s+confirmation\b/,
  ];
  
  for (const pat of actionResponse) {
    if (pat.test(s) || pat.test(b)) {
      return { decided: true, pertains: true, reason: "response to student action (strict local rule)" };
    }
  }

  // 5. Common irrelevant patterns (high confidence filtering)
  const definitelyIrrelevant = [
    /\b(campus|student)\s+(events?|activities|life|newsletter)\b/,
    /\bweekly\s+(digest|update|newsletter)\b/,
    /\bupcoming\s+events\b/,
    /\bjoin\s+us\s+(for|at)\b/,
    /\bopen\s+house\b/,
    /\bvirtual\s+tour\b/,
    /\bmeet\s+(the|our)\s+(students|faculty)\b/,
  ];
  
  for (const pat of definitelyIrrelevant) {
    if (pat.test(s) || pat.test(b)) {
      return { decided: true, pertains: false, reason: "marketing/events (strict local rule)" };
    }
  }

  return { decided: false, pertains: false, reason: "defer to AI" };
}

function enforceStrictRules_(meta, aiDecision) {
  const s = (meta.subject || "").toLowerCase();
  const b = (meta.body || "").toLowerCase();
  let pertains = aiDecision.pertains === true;
  let reason = aiDecision.reason || "AI decision";

  // STRICT OVERRIDE: Force relevant for security (can't miss these)
  if (!pertains) {
    const criticalSecurity = [
      /\bpassword\s+reset\b/,
      /\bsecurity\s+alert\b/,
      /\bverification\s+code\b/,
      /\baccount\s+locked\b/,
      /\bunusual\s+sign[- ]?in\b/,
      /\bsuspicious\s+activity\b/,
    ];
    for (const pat of criticalSecurity) {
      if (pat.test(s) || pat.test(b)) {
        pertains = true;
        reason = "STRICT OVERRIDE: security/password alert";
        break;
      }
    }
  }

  // STRICT OVERRIDE: Force relevant for explicit financial aid offers
  if (!pertains) {
    const explicitAid = [
      /\bfinancial\s+aid\b.*\boffer\b.*\bready\b/,
      /\baward\s+letter\b.*\b(ready|available|view)\b/,
      /\byour\s+aid\s+is\s+ready\b/,
    ];
    for (const pat of explicitAid) {
      if (pat.test(s) || pat.test(b)) {
        if (!/\blearn\s+more\b|\bapply\b/.test(s) && !/\blearn\s+more\b|\bapply\b/.test(b)) {
          pertains = true;
          reason = "STRICT OVERRIDE: financial aid offer ready";
          break;
        }
      }
    }
  }

  // STRICT ENFORCEMENT: Force NOT relevant for scholarship held/consideration
  if (pertains && reason.toLowerCase().includes("scholarship")) {
    const scholarshipNeg = [
      /\bscholarship\b.*\bheld\s+for\s+you\b/,
      /\bbeing\s+held\b/,
      /\bconsider(ed|ation)\b/,
      /\beligible\s+for\b/,
      /\bmay\s+qualify\b/,
      /\bapply\s+for\b/,
    ];
    for (const pat of scholarshipNeg) {
      if (pat.test(s) || pat.test(b)) {
        pertains = false;
        reason = "STRICT ENFORCEMENT: scholarship not actually awarded";
        break;
      }
    }
  }

  return { pertains, reason };
}

// ---------- AI call with retry logic ----------
function classifyWithAIRetry_(meta) {
  let lastError = null;
  let backoffMs = 1000; // Start with 1 second
  
  for (let attempt = 1; attempt <= MAX_AI_RETRIES; attempt++) {
    try {
      const result = classifyWithAI_(meta);
      
      // Validate AI response
      if (typeof result.pertains !== "boolean") {
        throw new Error(`Invalid AI response: pertains is not boolean (got ${typeof result.pertains})`);
      }
      if (!result.reason || typeof result.reason !== "string") {
        throw new Error("Invalid AI response: missing or invalid reason");
      }
      
      return result;
    } catch (e) {
      lastError = e;
      Logger.log(`AI attempt ${attempt}/${MAX_AI_RETRIES} failed: ${e}`);
      
      // Check if it's a rate limit error
      if (e.toString().includes("429") || e.toString().includes("rate limit")) {
        Logger.log(`Rate limit detected on attempt ${attempt}`);
        // Exponential backoff for rate limits: 2s, 4s, 8s
        backoffMs = Math.min(backoffMs * 2, 10000);
      }
      
      if (attempt < MAX_AI_RETRIES) {
        Logger.log(`Waiting ${backoffMs}ms before retry...`);
        Utilities.sleep(backoffMs);
        backoffMs *= 2; // Exponential backoff
      }
    }
  }
  
  // All retries failed
  return { 
    pertains: false, 
    reason: `AI failed after ${MAX_AI_RETRIES} attempts: ${lastError}`,
    error: true 
  };
}

function classifyWithAI_(meta) {
  const prompt = buildPrompt_(meta);
  const payload = {
    model: AI_MODEL,
    messages: [{ role: "user", content: prompt }],
    stream: false,
    temperature: 0.1,
    max_tokens: 150
  };
  
  const headers = {
    "Authorization": `Bearer ${AI_API_KEY}`,
    "Content-Type": "application/json"
  };

  let resp;
  try {
    resp = UrlFetchApp.fetch(AI_BASE_URL, {
      method: "post",
      payload: JSON.stringify(payload),
      headers,
      muteHttpExceptions: true,
      validateHttpsCertificates: true,
      timeout: AI_TIMEOUT_MS
    });
  } catch (e) {
    throw new Error(`AI request network error: ${e}`);
  }

  const status = resp.getResponseCode();
  
  // Handle rate limiting
  if (handleAIRateLimit_(resp)) {
    throw new Error(`AI rate limit (HTTP ${status})`);
  }
  
  if (status < 200 || status >= 300) {
    const errorBody = resp.getContentText().slice(0, 500);
    throw new Error(`AI HTTP ${status}: ${errorBody}`);
  }

  const text = resp.getContentText();
  if (!text) {
    throw new Error("AI returned empty response");
  }

  let pertains = false, reason = "default false (strict)";
  
  try {
    const json = JSON.parse(text);
    const content = (json.choices?.[0]?.message?.content) || "";
    
    if (!content) {
      throw new Error("AI response missing content");
    }
    
    const parsed = tryParseJSON_(content);
    
    if (parsed && typeof parsed.pertains === "boolean") {
      pertains = parsed.pertains;
      reason = parsed.reason || "AI decision (no reason provided)";
    } else {
      // Fallback parsing for non-JSON responses
      const lc = content.toLowerCase();
      
      if (/"\s*pertains\s*"\s*:\s*true/i.test(content) || /"true"/.test(content)) {
        pertains = true;
        reason = "AI indicated true (fallback parse)";
      } else if (/"\s*pertains\s*"\s*:\s*false/i.test(content) || /"false"/.test(content)) {
        pertains = false;
        reason = "AI indicated false (fallback parse)";
      } else {
        if (/\bsecurity\s+alert\b|\bpassword\s+reset\b|\bverification\s+code\b/.test(lc)) {
          pertains = true;
          reason = "fallback: security keywords detected";
        } else if (/\baward\s+letter\b.*\bready\b|\bfinancial\s+aid\b.*\boffer\b.*\bready\b/.test(lc)) {
          pertains = true;
          reason = "fallback: aid offer keywords detected";
        } else {
          throw new Error(`Could not parse AI response: ${content.slice(0, 200)}`);
        }
      }
    }
  } catch (e) {
    throw new Error(`AI parse error: ${e}. Response: ${text.slice(0, 500)}`);
  }

  return { pertains, reason };
}

function buildPrompt_(meta) {
  return [
    "You must return EXACTLY one JSON object with NO additional text: { \"pertains\": true|false, \"reason\": \"explanation\" }",
    "",
    "Return pertains=true ONLY IF the email meets ONE of these STRICT criteria:",
    "  A) Security/password alert (password reset, account locked, verification code, suspicious activity)",
    "  B) Scholarship AWARDED/RECEIVED (not held, not consideration, not eligible, not apply)",
    "  C) Financial aid offer explicitly READY/AVAILABLE to view/review (award letter posted/ready)",
    "  D) Confirmation of student action (application received, enrollment confirmed)",
    "",
    "Return pertains=false for:",
    "  - Marketing emails (learn more, join us, events, newsletters)",
    "  - Scholarship held/reserved/eligible/consideration/apply",
    "  - Financial aid applications or FAFSA reminders",
    "  - General announcements, campus events, open houses",
    "  - Anything that doesn't meet criteria A-D above",
    "",
    "When uncertain, return false. Be strict.",
    "",
    `From: ${meta.from}`,
    `To: ${meta.to}`,
    `Cc: ${meta.cc}`,
    `Subject: ${meta.subject}`,
    `Body: ${meta.body}`,
    "",
    "JSON response:"
  ].join("\n");
}

// ---------- Utilities ----------
function getOrCreateLabel_(name) {
  return GmailApp.getUserLabelByName(name) || GmailApp.createLabel(name);
}

function safeStr_(s, maxLen) {
  if (s === null || s === undefined) return "";
  s = s.toString().trim();
  if (maxLen && s.length > maxLen) return s.slice(0, maxLen);
  return s;
}

function tryParseJSON_(s) {
  if (!s) return null;
  
  try {
    return JSON.parse(s);
  } catch (e) {
    const codeBlockMatch = s.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
    if (codeBlockMatch) {
      try {
        return JSON.parse(codeBlockMatch[1]);
      } catch (e2) {}
    }
    
    const i = s.indexOf("{");
    const j = s.lastIndexOf("}");
    if (i !== -1 && j !== -1 && j > i) {
      try {
        return JSON.parse(s.slice(i, j + 1));
      } catch (e3) {}
    }
    
    return null;
  }
}

function setupTriggers() {
  ScriptApp.getProjectTriggers().forEach(trigger => {
    if (trigger.getHandlerFunction() === "runTriage") {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  ScriptApp.newTrigger("runTriage")
    .timeBased()
    .everyMinutes(10)
    .create();
  
  Logger.log("Trigger created: runTriage every 10 minutes");
}

// Manual functions for testing/debugging
function resetRateLimit() {
  const props = PropertiesService.getScriptProperties();
  props.deleteProperty(RATE_LIMIT_PROPERTY);
  props.deleteProperty(RATE_LIMIT_COUNT_PROPERTY);
  Logger.log("Rate limit reset");
}

function checkRateLimitStatus() {
  const props = PropertiesService.getScriptProperties();
  const count = getCurrentRateLimitCount_();
  const resetTime = props.getProperty(RATE_LIMIT_PROPERTY);
  
  Logger.log(`Rate limit status: ${count}/${MAX_AI_CALLS_PER_HOUR} calls`);
  if (resetTime) {
    Logger.log(`Reset time: ${new Date(parseInt(resetTime)).toISOString()}`);
  } else {
    Logger.log("No active rate limit window");
  }
}